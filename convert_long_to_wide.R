#' Convert Long Table to Wide Table with Type Restoration
#'
#' @description
#' Converts a long format data table (generated by convert_wide_to_long) back
#' to wide format, restoring the original data types based on the value_type
#' column. Values are extracted from the appropriate type-specific columns
#' (value_num, value_char, value_logic).
#'
#' @param data A data frame or data table in long format with the following
#'   required columns: feature, value_type, and at least one of value_num,
#'   value_char, or value_logic
#' @param id_cols Character vector of column names to use as ID variables.
#'   Default is c("s_id", "tp_id")
#'
#' @return A tibble in wide format where:
#'   \itemize{
#'     \item ID columns are preserved
#'     \item Each unique feature becomes a column
#'     \item Column data types are restored based on value_type
#'   }
#'
#' @details
#' The function uses the value_type column to determine which type-specific
#' column to extract values from:
#' \itemize{
#'   \item "numeric" -> extracts from value_num
#'   \item "character" -> extracts from value_char
#'   \item "logical" -> extracts from value_logic
#' }
#'
#' The function validates that required columns exist before conversion.
#'
#' @examples
#' \dontrun{
#' # Create sample long data
#' long_data <- data.frame(
#'   s_id = c(1, 1, 1, 2, 2, 2),
#'   tp_id = c("A", "A", "A", "B", "B", "B"),
#'   feature = c("age", "name", "active", "age", "name", "active"),
#'   value_type = c("numeric", "character", "logical",
#'                  "numeric", "character", "logical"),
#'   value_num = c(25, NA, NA, 30, NA, NA),
#'   value_char = c(NA, "John", NA, NA, "Jane", NA),
#'   value_logic = c(NA, NA, TRUE, NA, NA, FALSE)
#' )
#'
#' # Convert to wide format
#' wide_data <- convert_long_to_wide(long_data)
#'
#' # Convert with custom ID columns
#' wide_data <- convert_long_to_wide(long_data, id_cols = c("s_id"))
#' }
#'
#' @export
#' @import data.table
#' @import dplyr
#' @import tidyr
convert_long_to_wide <- function(data, id_cols = c("s_id", "tp_id")) {
  check_packages_for_wide()
  validate_long_format(data, id_cols)
  
  cat("Converting long format to wide format...\n")
  
  dt <- data.table::as.data.table(data)
  dt <- extract_values_by_type(dt)
  wide_dt <- pivot_to_wide_format(dt, id_cols)
  wide_dt <- restore_wide_column_types(wide_dt, data)
  
  result <- finalize_wide_result(wide_dt)
  
  cat("Complete! Final dataset has", nrow(result), "rows and",
      ncol(result), "columns\n")
  
  return(result)
}

check_packages_for_wide <- function() {
  required_pkgs <- c("tidyr", "dplyr", "data.table")
  for (pkg in required_pkgs) {
    if (!require(pkg, quietly = TRUE, character.only = TRUE)) {
      stop(paste(pkg, "package is required"))
    }
  }
}

validate_long_format <- function(data, id_cols) {
  required_cols <- c(id_cols, "feature", "value_type")
  value_cols <- c("value_num", "value_char", "value_logic")
  
  missing_required <- setdiff(required_cols, names(data))
  if (length(missing_required) > 0) {
    stop(paste("Missing required columns:", 
               paste(missing_required, collapse = ", ")))
  }
  
  has_value_col <- any(value_cols %in% names(data))
  if (!has_value_col) {
    stop("Data must have at least one value column: value_num, value_char, or value_logic")
  }
}

extract_values_by_type <- function(dt) {
  cat("Extracting values from type-specific columns...\n")
  
  dt[, value := NA_character_]
  
  if ("value_num" %in% names(dt)) {
    dt[value_type == "numeric" & !is.na(value_num), 
       value := as.character(value_num)]
  }
  
  if ("value_char" %in% names(dt)) {
    dt[value_type == "character" & !is.na(value_char), 
       value := value_char]
  }
  
  if ("value_logic" %in% names(dt)) {
    dt[value_type == "logical" & !is.na(value_logic), 
       value := as.character(value_logic)]
  }
  
  return(dt)
}

pivot_to_wide_format <- function(dt, id_cols) {
  cat("Pivoting data to wide format...\n")
  
  dt_for_pivot <- dt[, c(id_cols, "feature", "value"), with = FALSE]
  
  wide_dt <- dcast(dt_for_pivot, 
                   as.formula(paste(paste(id_cols, collapse = " + "), 
                                    "~ feature")),
                   value.var = "value",
                   fun.aggregate = function(x) x[1])
  
  return(wide_dt)
}

restore_wide_column_types <- function(wide_dt, original_data) {
  cat("Restoring original column types...\n")
  
  type_info <- original_data %>%
    dplyr::select(feature, value_type) %>%
    dplyr::distinct()
  
  for (i in seq_len(nrow(type_info))) {
    col_name <- type_info$feature[i]
    col_type <- type_info$value_type[i]
    
    if (col_name %in% names(wide_dt)) {
      wide_dt <- apply_column_type(wide_dt, col_name, col_type)
    }
  }
  
  return(wide_dt)
}

apply_column_type <- function(dt, col_name, col_type) {
  if (col_type == "numeric") {
    dt[, (col_name) := as.numeric(get(col_name))]
  } else if (col_type == "logical") {
    dt[, (col_name) := as.logical(get(col_name))]
  } else if (col_type == "character") {
    dt[, (col_name) := as.character(get(col_name))]
  }
  
  return(dt)
}

finalize_wide_result <- function(wide_dt) {
  cat("Finalizing results...\n")
  
  result <- wide_dt %>% dplyr::as_tibble()
  
  return(result)
}
